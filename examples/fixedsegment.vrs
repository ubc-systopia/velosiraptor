/*
 * This specification expresses a hypothetical direct segment. This is a single, contiguous
 * region of memory that is translated using a segment-like approach.
 *
 * The segment has a given maximum size, but the actual size can be configured.
 * Moreover, the translation functionality can be disabled.
 *
 * The state is given by two registers:
 *   base: that defines the base address and the permissions
 *   size: the active size of the segment
 *
 * The minimum translation size is 64 bytes.
 * The translation size is a multiple of 64 bytes.
 */

// This defines an SMPT Entry
unit FixedSegment(base : addr) : Segment {

    // let's assume the maximum size of the segment is 40 bits.
    // size = 40;

    // the state will be two registers:
    state = Register {

        base [8] {
            0 63  address;
        };
    };

    // the interface is a register interface, assume there are two registers
    // called `base` and `size`. They can be updated using load/store instructions
    interface = MMIO(base : addr) {
        base [base, 16, 8] {
            Layout {
               0 63  address;
            };
            ReadAction {
                interface.base <- state.base;
            };
            WriteAction {
                interface.base.address -> state.base.address;
            };
        };
    };

    // unmapping an entry
    fn unmap(va: addr, sz: size) -> bool
        // need a way to express:
        // forall a | va <= a < va + sz :: fail(translate(a, ANY))
        ensures translate(va, 0) == 0;
    ;

    // mapping an entry
    fn map(va: addr, sz: size, flags: int, pa : addr) -> bool
        //requires (addr %  4096) == 0;
        // need a way to express types:
        // type(addr) == Memory || type(addr) == DevMemory;
        // type(addr) == DevMemory ==> flags & CACHE_DISABLED
        //
        // the va should be 0 here
        requires va == 0;
        requires sz == 4096;

        requires 0 <= pa;
        requires pa & 0xfff == 0;
        requires ((pa >> 12) << 12) == pa;
        requires pa <= 0xff_ffff_ffff;

        ensures forall i : addr :: 0 <= i && i < sz && translate(va + i, flags) == pa + i;
        ensures translate(va, flags) == pa;
    ;


    // protecting the entry, i.e., change its permission
    fn protect(flags: int) -> bool
    {
        // update the entry
        // ensures match_flags(flags) ==> translate(a) == translate(a)
        return true;
    }


    // the translation semantics, adding an option type?
    fn translate(va: addr, flags: int) -> addr
        requires va < 4096;
    {
        return va + (state.base.address << 12);
    }

 };
