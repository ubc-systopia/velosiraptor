/*
 * The Xeon Phi System Memory Page Table (SMPT) consists of 32 16-GB pages that translate
 * from the Xeon Phi address space into the host address space.
 *
 * Each page in the SMPT is controlled by a single register, accessible from the host
 * and the Xeon Phi (note the address may be different here)
 *
 * The translation can only be remapped, but not unmapped nor are there any protection
 * mechanisms.
 */

const SMPT_ENTRY_SIZE : size = 4;
const SMTP_PAGE_BITS  : size = 34;
const SMTP_PAGE_SIZE  : size = (1 << SMTP_PAGE_BITS);  // 16 GB
const SMPT_NUM_ENTRIES : size = 32;

flags {
    snoop_disabled,
}


// This defines an SMPT Entry
segment SMPTE(base: addr) {

    inbitwidth = SMTP_PAGE_BITS;
    outbitwidth = 64;

    state() {
        reg entry [ 4 ] {
            0 ..  1  snoop_disabled,
            1 ..  2  _,
            2 .. 32  host_address,
        }
    }

    interface(base: addr) {
        mmio entry [ base, 0, 4 ]
    }

    #[remap]
    fn valid() -> bool {
        true    // cannot unmap
    }

    #[remap]
    fn matchflags(flgs : flags) -> bool
    {
        true    // no protection here
    }

    fn translate(va: vaddr) -> paddr
        requires state.entry.snoop_disabled == 0;
        requires va < SMTP_PAGE_SIZE;
    {
        va + (state.entry.host_address << 34)
    }

    synth fn map(va: vaddr, sz: size, flgs: flags, pa : paddr)
        requires va == 0 && sz == SMTP_PAGE_SIZE
        requires (pa & (SMTP_PAGE_SIZE - 1) == 0)

    // can't actually do anything to protect or unmap
    synth fn protect(va: vaddr, sz: size, flgs: flags);
    synth fn unmap(va: vaddr, sz: size);
 }

staticmap SMPT(base: addr) {
    maps [ SMPTE(base + i * SMPT_ENTRY_SIZE) for i in 0..SMPT_NUM_ENTRIES ]
}