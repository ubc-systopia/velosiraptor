/*
 * 32-bit paging on the x86 architecture involves a two-level page table. For simplicity, we focus
 * here on the leaf page table.
 *
 * A single page table is 4 KiB in total. It contains 1024 32-bit page-table entries.
 * The page table as a whole must be naturally aligned (4 KiB).
 * This also ensures that each entry is naturally aligned to 32-bits (or 4 bytes)
 *
 * The layout of a page table entry is as follows:
 * ```
 *     Bit(s)          Contents
 *     0       (P)     Present; must be 1 to map a 4-KByte page
 *     1       (R/W)   Read/write; if 0, writes may not be allowed to the 4-KByte page referenced
 *                     by this entry
 *     2       (U/S)   User/supervisor; if 0, user-mode accesses are not allowed to the 4-KByte
 *                     page referenced by this entry
 *     3       (PWT)   Page-level write-through; indirectly determines the memory type used to
 *                     access the 4-KByte page referenced by this entry
 *     4       (PCD)   Page-level cache disable; indirectly determines the memory type used to
 *                     access the 4-KByte page referenced by this entry
 *     5       (A)     Accessed; indicates whether software has accessed the 4-KByte page referenced
 *                     by this entry
 *     6       (D)     Dirty; indicates whether software has written to the 4-KByte page referenced by
 *                     this entry
 *     7       (PAT)   If the PAT is supported, indirectly determines the memory type used to access
 *                     the 4-KByte page referenced by this entry; otherwise, reserved (must be 0) 1
 *     8       (G)     Global; if CR4.PGE = 1, determines whether the translation is global;
 *                     ignored otherwise
 *     11:9    (IGN)   Ignored
 *     31:12           Physical address of the 4-KByte page referenced by this entry
 * ```
 */

// represents an x86 page table entry
unit X86_pte(base : addr) : Segment {
    // the state
    state = Memory(base : addr) {
        pte [base, 0, 4] {
            // the following fields at starting bit, ending bit, name
            0   0 present;
            1   1 writable;
            2   2 usermode;
            3   3 writethrough;
            4   4 nocache;
            5   5 accessed;
            6   6 dirty;
            7   7 pat;
            8   8 global;
            9  11 ignored;
           12  31 base;
        };
    };

    interface = Memory(base : addr) {
        pte [base, 0, 4] {
            Layout {
                // the following fields at starting bit, ending bit, name
                0   0 present,
                1   1 writable,
                2   2 usermode,
                3   3 writethrough,
                4   4 nocache,
                5   5 accessed,
                6   6 dirty,
                7   7 pat,
                8   8 global,
                9  11 ignored,
                12  31 base
            };
        };
    };

    // the base address where this entry translate to
    fn get_base() -> addr {
        return state.pte.base << 12;
    }


    // here the size is fixed
    fn get_size() -> size {
        return 4096;
    };


    // matches a translation flags,
    fn match_flags(flags : int) -> bool
    {
        if state.pte.present == 0 {
            return false;
        }

        // need a way to express the flags
        if (flags & !state.pte.writable) == 0 {
            return false;
        }
        // need a way to express the flags
        if (flags & !state.pte.usermode) == 0 {
            return false;
        }


        return true;
    }

    // unmapping an entry
    fn unmap(va: addr, sz: size) -> bool
        // need a way to express:
        // forall a | va <= a < va + sz :: fail(translate(a, ANY))
        ensures translate(va, 0) == 0;
    ;

    // mapping an entry
    fn map(va: addr, sz: size, flags: int, pa : addr) -> bool
        //requires (addr %  4096) == 0;
        // need a way to express types:
        // type(addr) == Memory || type(addr) == DevMemory;
        // type(addr) == DevMemory ==> flags & CACHE_DISABLED
        //
        ensures forall i : addr :: 0 <= i && i < sz && translate(va + i, flags) == pa + i;
        ensures translate(va, flags) == pa;
    ;


    // protecting the entry, i.e., change its permission
    fn protect(flags: int) -> bool
        ensures match_flags(flags);
    {
        // update the entry
        // ensures match_flags(flags) ==> translate(a) == translate(a)
        return true;
    }


    // the translation semantics, adding an option type?
    fn translate(va: addr, flags: int) -> addr
        requires va < get_size();
        requires match_flags(flags);
    {
        return va + get_base();
    }
};


// represents an x86 page table entry
unit X86_pt(base : addr) : StaticMap {
    staticmap = [ X86_pte(base + i * 4) for i in 0..1024 ];
};


/*
unit X86PageTableEntry(base: addr) {
    state = Memory(base: addr) {
        entry [base, 0, 8] {
             0  0 present;
            // more fields omitted
            12 63 frame_addr;
        };
    };
    // the interface has the same
    interface = Memory;

    // the translation semantics
    fn translate(va: addr, flags: int) -> addr
      requires state.entry.present; // present bit must be set
    {
        return (state.frame_addr << 12) + va;
    }
};


unit X86PageTable(base: addr) {
    // the table itself doesn't have state or interface

    // it has 512 entries expressed as a
    staticmap = [ X86PageTableEntry(base + i * 8) for i in 0..512 ];

    // translate basically forwards the translation to the entry
    fn translate(va: addr, flags: int) -> addr {
        return map[va / 4096].translate(va % 4096, flags);
    }
};
*/