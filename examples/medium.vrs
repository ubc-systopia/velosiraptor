/*
 * This specification expresses a hypothetical direct segment. This is a single, contiguous
 * region of memory that is translated using a segment-like approach.
 *
 * The segment has a given maximum size, but the actual size can be configured.
 * Moreover, the translation functionality can be disabled.
 *
 * The state is given by two registers:
 *   base: that defines the base address and the permissions
 *   size: the active size of the segment
 *
 * The minimum translation size is 64 bytes.
 * The translation size is a multiple of 64 bytes.
 */

flags {
    writable,
    readable,
    executable,
    user
}

segment SingleSegment(base : addr) {

    // let's assume the maximum size of the segment is 40 bits.
    inbitwidth= 48;

    // let's assume the maximum output bit size is 64 bits
    outbitwidth = 48;

    // the state will be two registers:
    state(base: addr) {
        reg address [ 8 ] {
            0 .. 4  res0,
            4 .. 48 val,
        },
        reg length [ 8 ] {
            0 .. 4  res0,
            4 .. 48 bytes,
        },
        reg permissions [ 8 ] {
            0 ..  1 present,
            1 ..  2 rw,
            2 ..  3 exec,
            3 ..  8 res0,
            8 .. 48 ign,
            48 .. 49 usr,
        },
        reg stats [ 8 ] {
             0 ..  8 stat0,
             8 .. 16 stat1,
            16 .. 24 stat2,
            24 .. 32 stat3,
            32 .. 40 stat4,
            40 .. 48 stat5,
            48 .. 56 stat6,
            56 .. 64 stat7,
        }
    }

    // just expose the entire state as MMIO interface
    interface(base: addr) {
        mmio address [ base, 0, 8 ],
        mmio length [ base, 8, 8 ],
        mmio permissions [ base, 16, 8 ],
        mmio stats [ base, 24, 8 ],
    }

    // add the valid bit
    #[remap]
    fn valid() -> bool {
        state.permissions.present == 1
    }

    #[remap]
    fn res0(va: vaddr) -> bool {
        state.address.res0 == 0
        && state.length.res0 == 0
        && state.permissions.res0 == 0
    }

    // #[remap]
    // fn range(va: vaddr) -> bool {
    //     va < (state.length.bytes << 4)
    // }

    // define the permission flags
    #[remap]
    fn matchflags(flgs : flags) -> bool
    {
        flgs.writable == state.permissions.rw && flgs.executable == state.permissions.exec
        && flgs.user == state.permissions.usr
    }

    // to calculate the new address, we just add the base address here, if within range
    fn translate(va: vaddr) -> paddr
        requires va < (state.length.bytes << 4)
    {
        va + (state.address.val << 4)
    }

    synth fn map(va: vaddr, sz: size, flgs: flags, pa : paddr)
        // requires sz < (1 << 40)
        requires sz > 0
        requires (sz & 0xf) == 0
        requires va == 0
        requires pa + sz < (1 << 48)
        requires (pa & 0xf == 0)

    synth fn protect(va: vaddr, sz: size, flgs: flags);

    synth fn unmap(va: vaddr, sz: size);
 }
