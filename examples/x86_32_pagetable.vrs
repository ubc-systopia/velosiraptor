/*
 * 32-bit paging on the x86 architecture involves a two-level page table. For simplicity, we focus
 * here on the leaf page table.
 *
 * A single page table is 4 KiB in total. It contains 1024 32-bit page-table entries.
 * The page table as a whole must be naturally aligned (4 KiB).
 * This also ensures that each entry is naturally aligned to 32-bits (or 4 bytes)
 *
 * The layout of a page table entry is as follows:
 * ```
 *     Bit(s)          Contents
 *     0       (P)     Present; must be 1 to map a 4-KByte page
 *     1       (R/W)   Read/write; if 0, writes may not be allowed to the 4-KByte page referenced
 *                     by this entry
 *     2       (U/S)   User/supervisor; if 0, user-mode accesses are not allowed to the 4-KByte
 *                     page referenced by this entry
 *     3       (PWT)   Page-level write-through; indirectly determines the memory type used to
 *                     access the 4-KByte page referenced by this entry
 *     4       (PCD)   Page-level cache disable; indirectly determines the memory type used to
 *                     access the 4-KByte page referenced by this entry
 *     5       (A)     Accessed; indicates whether software has accessed the 4-KByte page referenced
 *                     by this entry
 *     6       (D)     Dirty; indicates whether software has written to the 4-KByte page referenced by
 *                     this entry
 *     7       (PAT)   If the PAT is supported, indirectly determines the memory type used to access
 *                     the 4-KByte page referenced by this entry; otherwise, reserved (must be 0) 1
 *     8       (G)     Global; if CR4.PGE = 1, determines whether the translation is global;
 *                     ignored otherwise
 *     11:9    (IGN)   Ignored
 *     31:12           Physical address of the 4-KByte page referenced by this entry
 * ```
 */


const PTABLE_ENTRIES    : size = 1024;
const PTABLE_ENTRY_SIZE : size = 4;
const PTABLE_SIZE       :size = (PTABLE_ENTRIES * PTABLE_ENTRY_SIZE);
const PTABLE_ALIGNMENT  : size = PTABLE_SIZE;


const BASE_PAGE_BITS  : size = 12;
const BASE_PAGE_SIZE  : size = (1 << BASE_PAGE_BITS); // 4 KiB

const LARGE_PAGE_BITS : size = 22;
const LARGE_PAGE_SIZE : size = (1 << LARGE_PAGE_BITS); // 4 MiB

const PHYS_ADDR_BITS : size = 32;
const PHYS_ADDR_MAX  : size = (1 << PHYS_ADDR_BITS);


flags {
    writable,
    readable,
    devicemem,
    usermode
}

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// x86_32 Page Table
//
////////////////////////////////////////////////////////////////////////////////////////////////////

// represents an x86 page table entry
segment X8632PageTableEntry(base : paddr) {

    // there are there are 4 KiB pages
    inbitwidth = BASE_PAGE_BITS;

    // it's a 32-bit machine
    outbitwidth = PHYS_ADDR_BITS;


    // the state
    state(base: paddr) {
        mem pte [base, 0, 4] {
            // the following fields at starting bit, ending bit, name
            0 ..  1 present,
            1 ..  2 writable,
            2 ..  3 usermode,
            3 ..  4 writethrough,
            4 ..  5 nocache,
            5 ..  6 accessed,
            6 ..  7 dirty,
            7 ..  8 pat,
            8 ..  9 global,
            9 .. 12 ignored,
           12 .. 32 base,
        }
    }

    interface(base : paddr) {
        mem pte [base, 0, 4]
    }

    fn valid() -> bool {
        state.pte.present == 1
    }

    // matches a translation flags,
    fn matchflags(flgs : flags) -> bool
    {
        (state.pte.writable == flgs.writable)
         && (state.pte.usermode != flgs.usermode)
         && if (flgs.devicemem == 1) {
               (state.pte.nocache == 1 && state.pte.writethrough == 1)
            } else {
                (state.pte.nocache == 0 && state.pte.writethrough == 0)
            }
         && (state.pte.accessed == 1)
         && (state.pte.global == 0)
         && (state.pte.dirty == 0)
    }

    // the translation semantics, adding an option type?
    fn translate(va: vaddr) -> paddr
        requires va < BASE_PAGE_SIZE;
    {
        va + (state.pte.base << BASE_PAGE_BITS)
    }

    // unmapping an entry
    synth fn unmap(va: vaddr, sz: size)
        requires (va == 0);
        requires sz == BASE_PAGE_SIZE;


    // mapping an entry
    synth fn map(va: vaddr, sz: size, flgs: flags, pa : paddr)
        requires va == 0;
        requires sz == BASE_PAGE_SIZE;
        requires (pa & (BASE_PAGE_SIZE - 1)) == 0;

    // protecting the entry, i.e., change its permission
    synth fn protect(va: vaddr, sz: size, flgs: flags)
}


// represents an x86 page table entry
staticmap X8632PageTable(base : paddr) {
    maps [ X8632PageTableEntry(base + i * PTABLE_ENTRY_SIZE) for i in 0..1024 ]
}


////////////////////////////////////////////////////////////////////////////////////////////////////
//
// x86_32 Page Directory
//
////////////////////////////////////////////////////////////////////////////////////////////////////

// represents an x86 page table entry
segment X8632PageDirectoryEntryFrame(base : paddr) {

    inbitwidth = LARGE_PAGE_BITS;

     outbitwidth = PHYS_ADDR_BITS;

    state(base :paddr) {
        mem entry [ base, 0, 8] {
            0 ..  1 present,
            1 ..  2 rw,  // Read/write; if 0, writes may not be allowed to the page
            2 ..  3 us,  // if 0, user-mode accesses are not allowed to the page
            3 ..  4 pwt, // Page-level write-through;
            4 ..  5 pcd, // Page-level cache disable
            5 ..  6 a,   // Accessed;
            6 ..  7 d,   // dirty
            7 ..  8 ps,  // page size
            8 ..  9 g,   // global
            9 .. 12 ign_0,
            12 .. 13 pat,
            13 .. 21 res0_0,
            21 .. 32 address,
        }
    }

    interface(base: paddr) {
        mem entry [ base, 0, 8 ]
    }

    #[remap]
    fn valid() -> bool {
        state.entry.present == 1
    }

    #[remap]
    fn matchflags(flgs : flags) -> bool
    {
        (state.entry.rw == flgs.writable)
         && if (flgs.devicemem == 1) {
                (state.entry.pcd == 1 && state.entry.pwt == 1)
            } else {
                (state.entry.pcd == 0 && state.entry.pwt == 0)
            }
         && (state.entry.us == flgs.usermode)
    }

    fn translate(va: vaddr) -> paddr
        requires state.entry.ps == 1
        requires va < LARGE_PAGE_SIZE

    {
        va + (state.entry.address << LARGE_PAGE_BITS)
    }

    synth fn map(va: vaddr, sz: size, flgs: flags, pa : paddr)
        requires va == 0 && sz == LARGE_PAGE_SIZE
        requires (pa & (LARGE_PAGE_SIZE - 1) == 0)

    synth fn protect(va: vaddr, sz: size, flgs: flags);

    synth fn unmap(va: vaddr, sz: size)
        requires va == 0 && sz == LARGE_PAGE_SIZE

}

segment X8632PageDirectoryEntryTable(base : paddr) {

    // there are there are 4 KiB pages
    inbitwidth = LARGE_PAGE_BITS;

    // it's a 32-bit machine
    outbitwidth = PHYS_ADDR_BITS;

    state(base: paddr) {
        mem entry [ base, 0, 8 ] {
            0 ..  1 present,  // whether this entry is valid
            1 ..  2 rw,       // Read/write; if 0, writes may not be allowed to the 512-GByte region controlled by this entry
            2 ..  3 us,       // if 0, user-mode accesses are not allowed to the 512-GByte region controlled by this entry
            3 ..  4 pwt,      // Page-level write-through;
            4 ..  5 pcd,      // Page-level cache disable
            5 ..  6 a,        // Accessed;
            6 ..  7 ignored0,
            7 ..  8 ps,
            8 .. 12 ignored1,
            12 .. 32 address,
        }
    }

    interface(base: paddr) {
        mem entry [ base, 0, 8 ]
    }

    #[remap]
    fn valid() -> bool {
        state.entry.present == 1
    }

    #[remap]
    fn matchflags(flgs : flags) -> bool
    {
        // TODO: make this one here a bit better
        (state.entry.rw == 1)      // always writable
         && (state.entry.us == 1)  // allow user access
         && (state.entry.pwt == 0) // don't do write back
         && (state.entry.pcd == 0) // don't disable cches
    }

    fn translate(va: vaddr) -> paddr
        requires state.entry.ps == 0
    {
        va + (state.entry.address << 12)
    }

    // unmapping an entry
    synth fn unmap(va: vaddr, sz: size)
        requires (va == 0);
        requires sz == BASE_PAGE_SIZE;


    // mapping an entry
    synth fn map(va: vaddr, sz: size, flgs: flags, pa : X8632PageTable)
        requires va == 0;
        requires sz == BASE_PAGE_SIZE;
        requires (pa & (BASE_PAGE_SIZE - 1)) == 0;

    // protecting the entry, i.e., change its permission
    synth fn protect(va: vaddr, sz: size, flgs: flags)

}

enum X8632PageDirectoryEntry(base: paddr){
    X8632PageDirectoryEntryFrame(base),
    X8632PageDirectoryEntryTable(base)
}

// represents an x86 page directory entry
staticmap X8632PageDirectory(base : paddr) {
    maps [ X8632PageDirectoryEntry(base + i * PTABLE_ENTRY_SIZE) for i in 0..1024 ]
}
