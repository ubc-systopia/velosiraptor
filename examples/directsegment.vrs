/*
 * This specification expresses a hypothetical direct segment. This is a single, contiguous
 * region of memory that is translated using a segment-like approach.
 *
 * The segment has a given maximum size, but the actual size can be configured.
 * Moreover, the translation functionality can be disabled.
 *
 * The state is given by two registers:
 *   base: that defines the base address and the permissions
 *   size: the active size of the segment
 *
 * The minimum translation size is 64 bytes.
 * The translation size is a multiple of 64 bytes.
 */

// This defines an SMPT Entry
unit DirectSegment : Segment {

    // let's assume the maximum size of the segment is 40 bits.
    size = 40;

    // the state will be two registers:
    state = Register {
        src_addr [8] {
             0  5  _;
             6 64  address;
        }

        dst_addr [8] {
             0  0  enabled;
             1  1  read;
             2  2  write;
             6 64  address;
        };
        length [8] {
            0  5 _;
            6 40 bytes
        };
    };

    // the interface is a register interface, assume there are two registers
    // called `base` and `size`. They can be updated using load/store instructions
    interface = Register {
        dsbase <=> state.src_addr;
        dssize <=> state.length;
        dsdst <=> state.dst_addr;
    };

    /* segment specific elements */

    // the base address will be the address part shifted by 6
    fn segbase() -> addr {
        return state.src_addr.address << 6
    }

    // the size is given by the state
    fn segsize() -> size {
        return state.length.bytes << 6;
    }

    //
    fn dstaddr() -> addr {
        return state.dst_addr.address << 6;
    }

    fn enabled() -> bool {
        return state.dst_addr.enabled;
    }

    // unmapping an entry
    fn unmap(va: addr, sz: size) -> bool
        // need a way to express:
        // forall a | va <= a < va + sz :: fail(translate(a, ANY))
        ensures translate(va, 0) == 0;
    ;

    // mapping an entry
    fn map(va: addr, sz: size, flags: int, pa : addr) -> bool
        //requires (addr %  4096) == 0;
        // need a way to express types:
        // type(addr) == Memory || type(addr) == DevMemory;
        // type(addr) == DevMemory ==> flags & CACHE_DISABLED
        //
        ensures forall i : addr :: 0 <= i && i < sz && translate(va + i, flags) == pa + i;
        ensures translate(va, flags) == pa;
    ;


    // protecting the entry, i.e., change its permission
    fn protect(flags: int) -> bool
        ensures match_flags(flags);
    {
        // update the entry
        // ensures match_flags(flags) ==> translate(a) == translate(a)
        return true;
    }


    // the translation semantics, adding an option type?
    fn translate(va: addr, flags: int) -> addr
        requires va < segbase() + segsize();
        requires segbase() <= va
        requires
    {
        return va + get_base();
    }
 }
