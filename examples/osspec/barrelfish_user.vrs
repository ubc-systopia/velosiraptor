const FOO : int = 1234;

flags {
    read, write
}

osspec MyOs {
    const BAR : int = 1234;

    extern type MyErrval { }

    extern type MyCapref {}

    #[desc]
    extern type MyVNode {
        cap: MyCapref,
        mapping: MyCapref,
    }

    #[frame]
    extern type MyFrame {
        cap: MyCapref,
        mapping: MyCapref,
    }

    // functions to allocate and free memory
    #[malloc]
    extern fn os_virt_alloc(sz: size) -> vaddr

    #[mfree]
    extern fn os_virt_free(va: vaddr, sz:size)

    #[malloc]
    extern fn os_vnode_alloc(ty: UnitType) -> MyVNode

    #[mfree]
    extern fn os_vnode_free(vnode: MyVNode)

    extern fn vnode_is_valid(vnode: MyVNode) -> bool

    // extern fn get_vnode_for_va(va: vaddr) -> vnode
    extern fn frame_to_paddr(pa: MyFrame) -> paddr
    extern fn get_vnode_for_va(va: vaddr) -> MyCapref
    extern fn get_mapping_for_va(va: vaddr) -> MyCapref

    extern fn errval_to_bool(err: MyErrval) -> bool

    extern fn my_vnode_map(dest: MyCapref, src: MyCapref, va: vaddr,
                        attr: flags, off: addr, sz: size,
                        mapping: MyCapref) -> MyErrval

    extern fn my_vnode_unmap(table: MyCapref, mapping: MyCapref) -> MyErrval

    extern fn my_vnode_modify_flags(table: MyCapref, va: vaddr, sz: size, attr: flags) -> MyErrval;

    fn map_vnode(va: vaddr, sz: size, flgs: flags, pa: MyVNode) -> bool {
        errval_to_bool(my_vnode_map(self.cap, pa.cap, va, flgs, 0, sz, pa.mapping))
    }

    fn map_frame(va: vaddr, sz: size, flgs: flags, pa: MyFrame) -> bool {
        errval_to_bool(my_vnode_map(self.cap, pa.cap, va, flgs, 0, sz, pa.mapping))
    }

    fn protect(va: vaddr, sz: size, flgs: flags) -> bool {
        errval_to_bool(my_vnode_modify_flags(self.cap, va, sz, flgs))
    }

    fn unmap(va: vaddr, sz: size) -> bool {
        errval_to_bool(my_vnode_unmap(self.cap, get_mapping_for_va(va)))
    }
}

