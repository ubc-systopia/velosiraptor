/*
 * This describes an x86 MMU
 */

// This defines an SMPT Entry
unit MMU {

    // the MMU map 48 bits of internal address space
    size = 48;

    // the state is given as a register
    state = Register {
        cr3 = [ _, _, _ ] {
             0 11 pcid,
            12 63 base
        },

        cr0 = [_, _, _] {
            31 31 pagig_enabled;
        }
    };

    // the interface is given by the MMIO register
    interface = RegisterMove {
        cr3 => state.cr3;
        cr0 => state.cr0;
    };

    // constructor
    MMU() {

    }

    // the translation function is basically forwarded to the next
    // element.
    translate(vaddr) -> paddr {
        if state.cr0.paging_enabled {
            // here the translation actually moves forward
            return  addr @ PML4(state.cr3.base << 12)
        } else {
            return paddr;
        }
    }

    map(addr, flags) {
        assert type(addr) == PML4
        assert aligned(addr, 4k);
        assert size(addr) == 4k;
    }

    // can't unmap
    unmap();

    // can't protect
    protect();
 }



