/**
 * Intel 64 and IA-32 Architectures Software Developer's Manual
 * ============================================================
 *
 * Volume 3 - Chapter 3: Protected Mode Memory Management
 * 3.4.5 Segment Descriptors
 */

const SMPT_ENTRY_SIZE : size = 4;
const SMTP_PAGE_BITS  : size = 34;
const SMTP_PAGE_SIZE  : size = (1 << SMTP_PAGE_BITS);  // 16 GB


const TYPE_EXECUTE_MASK : size = (0b1000);
const TYPE_WRITE_MASK : size = (0b0010);
const TYPE_READ_MASK  : size = (0b0010);
const TYPE_ACCESSED_MASK : size = (0b0001);

const SEGMENT_GRANULARITY_SIZE : size = 4096;

const SEGMENT_SIZE_MAX : size = 0xffff_ffff;


flags {
    execute,
    read,
    write,
    usermode
}

// This defines an SMPT Entry
abstract segment SegmentDescriptorBase(base: addr) {

    inbitwidth = 32;
    outbitwidth = 32;



    state(base: addr) {
        mem entry_lo [ base, 0, 4 ] {
            0  .. 16 limit0,  // segment limit [15:0]
            16 .. 32 base0,   // base[15:0]
        },
        mem entry_hi [ base, 4, 4 ] {
             0 ..  8  base1,  // base[16:23]
             8 .. 12  typ,    // the type of the
            12 .. 13  s,      // system or data/code
            13 .. 15  dpl,    // privilege level (ring)
            15 .. 16  p,      // present
            16 .. 20  limit1, // limit[16:19]
            20 .. 21  avl,    // available for use by system software
            21 .. 22  l,      // 64-bit long mode
            22 .. 23  db,     // default operation size, 0 == 16 bit, 1 = 32 bit
            23 .. 24  g,      // granularity, if limit is in 4 KiB increments
            24 .. 32  base2,  // base[32..24]
        }
    }

    interface(base: addr) {
        mem entry_lo [ base, 0, 4 ],
        mem entry_hi [ base, 4, 4 ],
    }

    #[remap]
    abstract fn matchflags(flgs : flags) -> bool;

    fn limit() -> size {
        (state.entry_lo.limit0 | state.entry_hi.limit1 << 16) *
        if state.entry_hi.g == 1 {
            SEGMENT_GRANULARITY_SIZE
        } else {
            1
        }
    }

    fn translate(va: vaddr) -> paddr
        requires state.entry_hi.p == 1;
        requires state.entry_hi.db == 1;
        requires va < limit();
    {
        va + (state.entry_lo.base0
              | state.entry_hi.base1 << 16
              | state.entry_hi.base2 << 24)
    }
}


segment SegmentDescriptorSystem(base: addr) : SegmentDescriptorBase {


    fn matchflags(flgs : flags) -> bool
        requires state.entry_hi.p == 1;
        requires state.entry_hi.s == 1;
        // can't execute and write at the same time
        // requires flgs.execute != flgs.write;
    {
        if flgs.usermode == 0 { state.entry_hi.dpl == 0 } else { state.entry_hi.dpl == 3 }

    }

    synth fn map(va: vaddr, sz: size, flgs: flags, pa : paddr)
        requires va == 0 && sz <= SEGMENT_SIZE_MAX
        requires (pa & (SMTP_PAGE_SIZE - 1) == 0)

    // can't actually do anything to protect or unmap
    synth fn protect(va: vaddr, sz: size, flgs: flags);

    synth fn unmap(va: vaddr, sz: size);
}

segment SegmentDescriptorData(base: addr) : SegmentDescriptorBase {



    #[remap]
    fn matchflags(flgs : flags) -> bool
        requires state.entry_hi.p == 1;
        requires state.entry_hi.s == 0;
        // can't execute and write at the same time
        // requires flgs.execute != flgs.write;
    {
        if flgs.usermode == 0 { state.entry_hi.dpl == 0 } else { state.entry_hi.dpl == 3 }
    }

    synth fn map(va: vaddr, sz: size, flgs: flags, pa : paddr)
        requires va == 0 && sz <= SEGMENT_SIZE_MAX
        requires (pa & (SMTP_PAGE_SIZE - 1) == 0)

    // can't actually do anything to protect or unmap
    synth fn protect(va: vaddr, sz: size, flgs: flags);

    synth fn unmap(va: vaddr, sz: size);
}

enum SegmentDescriptor(base: addr) {
    SegmentDescriptorData(base), SegmentDescriptorSystem(base)
}