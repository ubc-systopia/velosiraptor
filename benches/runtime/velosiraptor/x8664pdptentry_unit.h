/// 2022 Systopia Lab, Computer Science, University of British Columbia. All rights reserved.


// Unit Definitions for `X8664PDPTEntry`

// THIS FILE IS AUTOGENERATED BY THE VELOSIRAPTOR COMPILER



#ifndef X8664PDPTENTRY_UNIT_H_
#define X8664PDPTENTRY_UNIT_H_ 1


#include <stddef.h>

#include <assert.h>

#include "types.h"

#include "consts.h"

#include <myos.h>

#include "x8664pdptentrytable_unit.h"

#include "x8664pdptentrypage_unit.h"

//  --------------------------- Constants / Constructor -------------------------

/// Unit Type `X8664PDPTEntry`
/// @loc: examples/x86_64_pagetable.vrs:377:1
struct x8664pdptentry {
    uintptr_t base;
};

typedef struct x8664pdptentry x8664pdptentry__t;

static inline void x8664pdptentry_init(x8664pdptentry__t * unit, uint64_t base) {
    (unit)->base = base;
}

//  ----------------------------- Address Translation  --------------------------

//  ---------------------------- Map / Protect/ Unmap ---------------------------

static inline bool x8664pdptentry_is_valid(x8664pdptentry__t * unit) {
    x8664pdptentrytable__t v0;
    x8664pdptentrytable_init(&(v0), (unit)->base);
    x8664pdptentrypage__t v1;
    x8664pdptentrypage_init(&(v1), (unit)->base);
    return (x8664pdptentrytable_is_valid(&(v0)) || x8664pdptentrypage_is_valid(&(v1)));
}

static inline bool x8664pdptentry_is_table(x8664pdptentry__t * unit) {
    x8664pdptentrytable__t targetunit;
    x8664pdptentrytable_init(&(targetunit), (unit)->base);
    // Extracting the state values
    uint64_t state_entry_ps_val;
    state_entry_ps_val = x8664pdptentrytable_entry_ps__rd(&(targetunit));
    // Evaluate boolean expression on the state
    bool res;
    res = (state_entry_ps_val == 0x0);
    return res;
}

static inline bool x8664pdptentry_is_page(x8664pdptentry__t * unit) {
    x8664pdptentrypage__t targetunit;
    x8664pdptentrypage_init(&(targetunit), (unit)->base);
    // Extracting the state values
    uint64_t state_entry_ps_val;
    state_entry_ps_val = x8664pdptentrypage_entry_ps__rd(&(targetunit));
    // Evaluate boolean expression on the state
    bool res;
    res = (state_entry_ps_val == 0x1);
    return res;
}

//  ----------------------------- Allocate and free ----------------------------

// not a group root, cannot allocate

// not a group root, cannot allocate

//  --------------------------- Higher Order Functions --------------------------

static inline size_t x8664pdptentry_map_page(x8664pdptentry__t * unit, vaddr_t va, size_t sz, flags_t flgs, paddr_t pa) {
    // Variant: X8664PDPTEntryPage mapping frame
    // TODO: check if there is already a valid mapping in there
    x8664pdptentrypage__t entry;
    x8664pdptentrypage_init(&(entry), (unit)->base);
    return x8664pdptentrypage_map(&(entry), va, sz, flgs, pa);
}

static inline size_t x8664pdptentry_map_table(x8664pdptentry__t * unit, vaddr_t va, size_t sz, flags_t flgs, x8664pdir__t * pa) {
    // Variant: X8664PDPTEntryTable mapping table
    // TODO: check if there is already a valid mapping in there
    x8664pdptentrytable__t entry;
    x8664pdptentrytable_init(&(entry), (unit)->base);
    return __x8664pdptentrytable_do_map(&(entry), va, sz, flgs, pa);
}

static inline size_t x8664pdptentry_map(x8664pdptentry__t * unit, vaddr_t va, size_t sz, flags_t flgs, paddr_t pa) {
    if ((((sz == 0x40000000) && (va == 0x0)) && ((pa & 0x3fffffff) == 0x0))) {
        // Variant: X8664PDPTEntryPage mapping frame
        // TODO: check if there is already a valid mapping in there
        x8664pdptentrypage__t entry;
        x8664pdptentrypage_init(&(entry), (unit)->base);
        return x8664pdptentrypage_map(&(entry), va, sz, flgs, pa);
    }
    if ((((((va + sz) <= 0x40000000) && (0x0 <= va)) && ((va & 0xfff) == 0x0)) && ((0x0 & 0xfff) == 0x0))) {
        // Variant: X8664PDPTEntryTable mapping table
        // TODO: check if there is already a valid mapping in there
        x8664pdptentrytable__t entry;
        x8664pdptentrytable_init(&(entry), (unit)->base);
        return x8664pdptentrytable_map(&(entry), va, sz, flgs, pa);
    }
    return false;
}

static inline size_t x8664pdptentry_protect(x8664pdptentry__t * unit, vaddr_t va, size_t sz, flags_t flgs) {
    // Variant: X8664PDPTEntryTable
    if (x8664pdptentry_is_table(unit)) {
        x8664pdptentrytable__t next;
        x8664pdptentrytable_init(&(next), (unit)->base);
        return x8664pdptentrytable_protect(&(next), va, sz, flgs);
    }
    // Variant: X8664PDPTEntryPage
    if (x8664pdptentry_is_page(unit)) {
        x8664pdptentrypage__t next;
        x8664pdptentrypage_init(&(next), (unit)->base);
        return x8664pdptentrypage_protect(&(next), va, sz, flgs);
    }
    return false;
}

static inline size_t x8664pdptentry_unmap(x8664pdptentry__t * unit, vaddr_t va, size_t sz) {
    // Variant: X8664PDPTEntryTable
    if (x8664pdptentry_is_table(unit)) {
        x8664pdptentrytable__t next;
        x8664pdptentrytable_init(&(next), (unit)->base);
        return x8664pdptentrytable_unmap(&(next), va, sz);
    }
    // Variant: X8664PDPTEntryPage
    if (x8664pdptentry_is_page(unit)) {
        x8664pdptentrypage__t next;
        x8664pdptentrypage_init(&(next), (unit)->base);
        return x8664pdptentrypage_unmap(&(next), va, sz);
    }
    return false;
}

static inline bool x8664pdptentry_resolve(x8664pdptentry__t * unit, vaddr_t va, paddr_t * pa) {
    // Variant: X8664PDPTEntryTable
    if (x8664pdptentry_is_table(unit)) {
        x8664pdptentrytable__t next;
        x8664pdptentrytable_init(&(next), (unit)->base);
        return x8664pdptentrytable_resolve(&(next), va, pa);
    }
    // Variant: X8664PDPTEntryPage
    if (x8664pdptentry_is_page(unit)) {
        x8664pdptentrypage__t next;
        x8664pdptentrypage_init(&(next), (unit)->base);
        return x8664pdptentrypage_resolve(&(next), va, pa);
    }
    return false;
}

#endif // X8664PDPTENTRY_UNIT_H_
