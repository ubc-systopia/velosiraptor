// Velosiraptor Synthesizer
//
//
// MIT License
//
// Copyright (c) 2023 Systopia Lab, Computer Science, University of British Columbia
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

//! Query Verifier

use std::collections::LinkedList;
/// std imports
use std::fmt::{Debug, Display, Formatter, Result as FmtResult};
use std::rc::Rc;

// library imports
use smt2::{Smt2Context, SortedVar, Term, VarBinding};
use velosiast::ast::{VelosiAstExpr, VelosiAstMethod};

// carte imports
use crate::{
    model::expr::expr_to_smt2,
    model::method::{call_method, call_method_assms, combine_method_params},
    model::types,
    z3::{Z3Query, Z3TaskPriority, Z3Ticket, Z3WorkerPool},
    Program,
};

//use super::queryhelper::{MaybeResult, ProgramBuilder, QueryBuilder};
use super::MaybeResult;

// use crate::ProgramsIter;

use super::utils;
use super::ProgramBuilder;

/// the default batch size for submitting the queries to Z3
pub const DEFAULT_BATCH_SIZE: usize = 5;

////////////////////////////////////////////////////////////////////////////////////////////////////
// Program Verifier
////////////////////////////////////////////////////////////////////////////////////////////////////

/// The Program Verifier
///
/// The program verifier takes the programs that are generated by the program builder and submits
/// the queries to Z3 for verification. It does submit a batch of queries at a time.
pub struct ProgramVerifier {
    /// sequence of queries to be submitted
    programs: Box<dyn ProgramBuilder>,
    /// the priority of the task
    priority: Z3TaskPriority,
    /// the submitted/in-flight queries
    submitted: LinkedList<Z3Ticket>,
    /// programs that had SAT results
    completed: LinkedList<Program>,
    /// the batch size for submiting queries
    batch_size: usize,
    /// whether we're done processing
    queries_done: bool,
    /// statistics on the number of queries run
    stat_num_queries: usize,
    /// statistics on the number of queries that turned out to be SAT
    stat_num_sat: usize,
}

impl ProgramVerifier {
    /// creates a new query verifier for the queries with the given priority
    pub fn new(queries: Box<dyn ProgramBuilder>, priority: Z3TaskPriority) -> Self {
        Self::with_batchsize(queries, DEFAULT_BATCH_SIZE, priority)
    }

    /// creates a new query verifier for the queries with the given priority and batch size
    pub fn with_batchsize(
        programs: Box<dyn ProgramBuilder>,
        batch_size: usize,
        priority: Z3TaskPriority,
    ) -> Self {
        let batch_size = std::cmp::max(batch_size, 1);
        ProgramVerifier {
            programs,
            priority,
            submitted: LinkedList::new(),
            completed: LinkedList::new(),
            batch_size,
            queries_done: false,
            stat_num_queries: 0,
            stat_num_sat: 0,
        }
    }

    fn to_smt_query(&self, prog: Program) -> Box<Z3Query> {
        let m_op = self.programs.m_op();
        let assms = self.programs.assms();
        let goal_expr = self.programs.goal_expr();
        let mem_model = false;

        // convert the program to a smt2 term
        let (mut smt, symvars) = prog.to_smt2_term(m_op.ident(), m_op.params.as_slice(), mem_model);

        // obtain the forall params
        let stvar = SortedVar::new("st!0".to_string(), types::model());
        let vars = combine_method_params(vec![stvar], m_op.params.as_slice(), &[]);

        // build up the pre-conditions (lhs of the implication)
        let pre1 = call_method_assms(m_op, "st!0");
        let mut pre = assms
            .iter()
            .fold(pre1, |acc, assm| Term::land(acc, assm.clone()));
        if mem_model {
            pre = utils::add_empty_wbuffer_precond(pre);
        }

        // call the program method

        let args = m_op
            .params
            .iter()
            .fold(vec![Term::from("st!0")], |mut acc, param| {
                acc.push(Term::from(param.ident().as_str()));
                acc
            });
        let m_op_call = call_method(m_op, args);

        // form the implication `let st = OP() in pre => goal`
        let impl_term = Term::Let(
            vec![VarBinding::new("st".to_string(), m_op_call)],
            Box::new(pre.implies(expr_to_smt2(&goal_expr, "st"))),
        );

        // build the forall term for the query
        let t_assert = Term::forall(vars, impl_term);

        // get the goal string for the query
        let goal_str = t_assert.to_string();

        // assert and check sat
        smt.assert(t_assert);
        smt.check_sat();

        // add the printing of the symvars
        symvars.add_get_values(&mut smt);

        // now form a new context with the smt context in a new level
        let mut smtctx = Smt2Context::new();
        smtctx.subsection(String::from("Verification"));
        smtctx.level(smt);

        // create and submit query
        let mut query = Z3Query::from(smtctx);
        query.set_program(prog).set_goal(goal_str);

        Box::new(query)
    }

    /// submits one query to the z3 worker pool
    pub fn submit_one(&mut self, z3: &mut Z3WorkerPool) -> bool {
        self.do_submit(z3, Some(1))
    }

    /// submits all queries to the z3 worker pool
    pub fn submit_all(&mut self, z3: &mut Z3WorkerPool) -> bool {
        self.do_submit(z3, None)
    }

    /// submits the supplied number of elements from the queue
    pub fn submit_n(&mut self, z3: &mut Z3WorkerPool, num: usize) -> bool {
        self.do_submit(z3, Some(num))
    }

    /// submits `num` queries to the Z3 worker pool
    pub fn submit(&mut self, z3: &mut Z3WorkerPool) -> bool {
        self.do_submit(z3, Some(self.batch_size))
    }

    /// processes the results of the submitted queries
    pub fn process_results(&mut self, z3: &mut Z3WorkerPool) -> bool {
        self.do_check_submitted(z3);
        !self.completed.is_empty()
    }

    /// handles submitting up `num` queries to the verifier, if None all ready queries are submitted
    fn do_submit(&mut self, z3: &mut Z3WorkerPool, num: Option<usize>) -> bool {
        let mut has_submitted = false;
        loop {
            // check the supplied limit
            if let Some(num) = num {
                if self.submitted.len() >= 2 * num {
                    // we've reached the limit of queries to be submitted, let's return
                    // true if we have submitted anything or we know that we're not done
                    return has_submitted || !self.queries_done;
                }
            }

            // try to submit equeries to the verifier
            match self.programs.next(z3) {
                MaybeResult::Some(prog) => {
                    // we got a new query to submit, try submitting it to the solver and
                    // record that we've submitted a query
                    has_submitted = true;

                    let query = self.to_smt_query(prog);
                    match z3.submit_query(query, self.priority) {
                        Ok(ticket) => {
                            self.stat_num_queries += 1;
                            self.submitted.push_back(ticket)
                        }
                        Err(e) => panic!("Error submitting query: {}", e),
                    }
                }
                MaybeResult::Pending => {
                    // we can submit more queries, but the queries are not ready yet
                    // returning true indicating there is some more work to be done
                    return true;
                }
                MaybeResult::None => {
                    // we've exhausted the queries, set the queries done flag and return
                    // whether we've submitted any new queries
                    self.queries_done = true;
                    return has_submitted;
                }
            }
        }
    }

    /// checks the submitted queries for results
    fn do_check_submitted(&mut self, z3: &mut Z3WorkerPool) {
        if self.submitted.is_empty() {
            return;
        }

        let mut submitted = LinkedList::new();
        while let Some(ticket) = self.submitted.pop_front() {
            if let Some(mut result) = z3.get_result(ticket) {
                let mut program = result.query_mut().take_program().unwrap();
                let output = result.result();
                if utils::check_result(output, &mut program) == utils::QueryResult::Sat {
                    self.stat_num_sat += 1;
                    self.completed.push_back(program);
                }
            } else {
                submitted.push_back(ticket);
            }
        }

        // update the submitted list
        self.submitted = submitted;
    }
}

impl ProgramBuilder for ProgramVerifier {
    fn next(&mut self, z3: &mut Z3WorkerPool) -> MaybeResult<Program> {
        self.do_check_submitted(z3);
        let pending = self.do_submit(z3, Some(self.batch_size));

        if let Some(p) = self.completed.pop_front() {
            MaybeResult::Some(p)
        } else if self.submitted.is_empty() && !pending {
            assert!(self.programs.next(z3) == MaybeResult::None);
            MaybeResult::None
        } else {
            MaybeResult::Pending
        }
    }

    fn m_op(&self) -> &VelosiAstMethod {
        self.programs.m_op()
    }

    fn assms(&self) -> Rc<Vec<Term>> {
        self.programs.assms()
    }

    fn goal_expr(&self) -> Rc<VelosiAstExpr> {
        self.programs.goal_expr()
    }

    fn do_fmt(&self, f: &mut Formatter<'_>, indent: usize, debug: bool) -> FmtResult {
        let i = " ".repeat(indent);
        writeln!(
            f,
            "{i} ? ProgramVerifier ({} / {})",
            self.stat_num_sat, self.stat_num_queries
        )?;
        self.programs.do_fmt(f, indent + 2, debug)
    }
}

/// Implement `From` for `ProgramVerifier
///
/// To allow conversions from ProgramVerifier -> Box<dyn ProgramBuilder>
impl From<ProgramVerifier> for Box<dyn ProgramBuilder> {
    fn from(q: ProgramVerifier) -> Self {
        Box::new(q)
    }
}

impl Display for ProgramVerifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> FmtResult {
        self.do_fmt(f, 0, false)
    }
}

impl Debug for ProgramVerifier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> FmtResult {
        self.do_fmt(f, 0, true)
    }
}
