const BASE_PAGE_BITS  : size = 12;
const BASE_PAGE_SIZE  : size = (1 << BASE_PAGE_BITS); // 4 KiB

// represents an x86 page table entry
segment myunit(base : addr) {

    inbitwidth = 32;
    outbitwidth = 32;

    flags = {
        writable,
        readable,
        devicemem,
        usermode
    };

    // the state
    state = StateDef(base: addr) {
        mem f [base, 0, 4] {
            // the following fields at starting bit, ending bit, name
            0 ..  1 present,
           12 .. 32 base,
        }
    };

    interface = InterfaceDef(base : addr) {
        mem f [base, 0, 4]
    };

    // matches a translation flags,
    fn matchflags(flgs : flags) -> bool
    {
        true
    }

    // the translation semantics, adding an option type?
    fn translate(va: vaddr) -> paddr
        requires va < BASE_PAGE_SIZE;
        requires state.f.present == 1;
    {
        va + (state.f.base << 12)
    }

    // unmapping an entry
    synth fn unmap(va: vaddr, sz: size)
        requires (va == 0);
        requires sz == BASE_PAGE_SIZE;
    {}

    // mapping an entry
    synth fn map(va: vaddr, sz: size, flgs: flags, pa : paddr)
        requires va == 0;
        requires sz == BASE_PAGE_SIZE;
        requires (pa & (BASE_PAGE_SIZE - 1)) == 0;

    // protecting the entry, i.e., change its permission
    synth fn protect(va: vaddr, sz: size, flgs: flags)
}