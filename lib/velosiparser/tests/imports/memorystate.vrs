
const PAGE_SIZE : int = 0x1000;

unit Foo {
    const PAGE_SIZE : int = 0x1000;

    state = Memory(base) {
        pte [base, 0, 4] {
            0   0   present,
            1   1   writable,
            3   3   writethrough,
            4   4   nocache,
            5   5   accessed,
            6   6   dirty,
            7   7   pat,
            8   8   global,
            9  11   ignored_field,
            12  31  base
        };
    };
};


    // unmapping an entry
    fn unmap(va: addr, sz: size)
        // need a way to express:
        // forall a | va <= a < va + sz :: fail(translate(a, ANY))
        ensures translate(va, 0) == 0;
    {

    }

    // protecting the entry, i.e., change its permission
    fn protect(flags: int)
        ensures match_flags(flags)
    {
        // update the entry
        // ensures match_flags(flags) ==> translate(a) == translate(a)
    }

    // the translation semantics, adding an option type?
    fn translate(va: addr, flags: int) -> addr
        requires va < get_size();
        requires match_flags(flags)
    {
        return va + get_base();
    }