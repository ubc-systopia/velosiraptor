// Velosiraptor Code Generator
//
//
// MIT License
//
// Copyright (c) 2021 Systopia Lab, Computer Science, University of British Columbia
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

//! Rust Code Generation Backend

use std::fs;
use std::fs::File;
use std::io::BufWriter;
use std::io::Write;
use std::path::Path;

use crate::ast::{Ast, State};
use crate::codegen::CodeGenBackend;
use crate::codegen::CodeGenError;

mod field;
mod interface;
mod utils;

/// The rust backend
///
/// # Generated File Structure
///
///  - outdir/pkgname/Cargo.toml            the library cargo.toml
///  - outdir/pkgname/src/lib.rs          the library file
///  - outdir/pkgname/src/<unit>/mod.rs        the unit module
///  - outdir/pkgname/src/<unit>/interface.rs  the interface
///  - outdir/pkgname/src/<unit>/fields/<field>.rs
pub struct BackendRust {
    outdir: Option<String>,
    pkgname: String,
    usedirs: Vec<String>,
}

impl BackendRust {
    pub fn new(pkgname: String, outdir: Option<String>) -> Self {
        let outdir = match outdir {
            Some(p) => Some(String::from(Path::new(&p).join(&pkgname).to_str().unwrap())),
            None => None,
        };
        BackendRust {
            outdir,
            pkgname,
            usedirs: Vec::new(),
        }
    }

    fn generate_tomlfile(&self, outfile: &Path) -> Result<(), CodeGenError> {
        // create the Cargo.toml
        let cargofile = File::create(outfile.join("Cargo.toml"))?;
        let mut cargo = BufWriter::new(cargofile);

        let mut lines = Vec::new();
        writeln!(
            lines,
            "# This file is auto generated by velosiraptor compiler. "
        )?;
        writeln!(lines, "[package]")?;
        writeln!(lines, "name = \"{}\"", self.pkgname)?;
        writeln!(
            lines,
            "description = \"Auto generated translation driver for '{}'.\"",
            self.pkgname
        )?;
        writeln!(lines, "license = \"MIT\"")?;
        writeln!(lines, "version = \"0.1.0\"")?;
        writeln!(
            lines,
            "authors = [\"Velosiraptor Compiler <no-reply@velosiraptor>\"]"
        )?;
        writeln!(lines, "edition = \"2018\"")?;
        writeln!(lines, "\n[dependencies]")?;
        writeln!(lines, "# none")?;

        cargo.write_all(&lines)?;
        cargo.flush()?;
        Ok(())
    }
}

impl CodeGenBackend for BackendRust {
    fn prepare(&self) -> Result<(), CodeGenError> {
        // create the output directory, if needed
        if let Some(p) = &self.outdir {
            // the root directory as supplied by backend
            let outdir = Path::new(p);

            // create the package path
            fs::create_dir_all(&outdir)?;

            // generate the toml file
            self.generate_tomlfile(&outdir)?;

            // create the source directory
            let srcdir = outdir.join("src");

            fs::create_dir_all(&srcdir)?;
        }
        Ok(())
    }
    fn generate_globals(&self, ast: &Ast) -> Result<(), CodeGenError> {
        for _const in &ast.consts {}
        Ok(())
    }

    fn generate_interfaces(&self, ast: &Ast) -> Result<(), CodeGenError> {
        for unit in &ast.units {
            let outdir = if let Some(p) = &self.outdir {
                // the root directory as supplied by backend
                let outdir = Path::new(p);
                let srcdir = outdir.join("src").join(unit.name.to_lowercase());
                fs::create_dir_all(&srcdir)?;
                Some(srcdir)
            } else {
                None
            };
            match &unit.state {
                State::MemoryState { bases, fields, pos } => {
                    for f in fields {
                        println!("generate interfaces fields");

                        field::generate(&unit.name, f, &outdir)
                    }
                }
                _ => (),
            }
        }
        Ok(())
    }

    fn generate_units(&self, _ast: &Ast) -> Result<(), CodeGenError> {
        Ok(())
    }

    fn finalize(&self) -> Result<(), CodeGenError> {
        if let Some(p) = &self.outdir {
            // the root directory
            let mut path = Path::new(p).to_path_buf();

            path.push("src");
            path.push("lib.rs");

            // create the Cargo.toml
            let librs = File::create(path)?;

            let mut librs = BufWriter::new(librs);

            let mut lines = Vec::new();
            writeln!(lines, "\n")?;
            for u in &self.usedirs {
                writeln!(lines, "pub use {}", u)?;
            }

            librs.write_all(&lines)?;
            librs.flush()?;
        }
        Ok(())
    }
}
