////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Registers Tests: OK
//
////////////////////////////////////////////////////////////////////////////////////////////////////

// represents an x86 page table entry
segment Seg(base : addr) {
    inbitwidth = 12;
    outbitwidth = 12;

    flags = { dummy };

    // the state
    state(base: addr) {
        reg pte [ 4 ]
    };

    interface(base : addr) {
        mmio pte [base, 0, 4]
    };

    fn valid() -> bool { true }

    // matches a translation flags,
    fn matchflags(flgs : flags) -> bool { true }

    // the translation semantics, adding an option type?
    fn translate(va: vaddr) -> paddr
    {
        va
    }

    synth fn unmap(va: vaddr, sz: size)
    synth fn map(va: vaddr, sz: size, flgs: flags, pa : paddr)
    synth fn protect(va: vaddr, sz: size, flgs: flags)
}

// represents an x86 page table entry
segment Seg2(base : addr) {
    inbitwidth = 12;
    outbitwidth = 12;

    flags = { dummy };

    // the state
    state(base: addr) {
        reg pte [ 4 ] {
            0..32 foo
        }
    };

    interface(base : addr) {
        mmio pte [base, 0, 4]
    };

    fn valid() -> bool { true }

    // matches a translation flags,
    fn matchflags(flgs : flags) -> bool { true }

    // the translation semantics, adding an option type?
    fn translate(va: vaddr) -> paddr
    {
        va
    }

    synth fn unmap(va: vaddr, sz: size)
    synth fn map(va: vaddr, sz: size, flgs: flags, pa : paddr)
    synth fn protect(va: vaddr, sz: size, flgs: flags)
}

// represents an x86 page table entry
segment Seg3(base : addr) {
    inbitwidth = 12;
    outbitwidth = 12;

    flags = { dummy };

    // the state
    state(base: addr) {
        reg pte [ 8 ]
    };

    interface(base : addr) {
        mmio pte [base, 0, 4]
    };

    fn valid() -> bool { true }

    // matches a translation flags,
    fn matchflags(flgs : flags) -> bool { true }

    // the translation semantics, adding an option type?
    fn translate(va: vaddr) -> paddr
    {
        va
    }

    synth fn unmap(va: vaddr, sz: size)
    synth fn map(va: vaddr, sz: size, flgs: flags, pa : paddr)
    synth fn protect(va: vaddr, sz: size, flgs: flags)
}

// represents an x86 page table entry
segment Seg4(base : addr) {
    inbitwidth = 12;
    outbitwidth = 12;

    flags = { dummy };

    // the state
    state(base: addr) {
        reg pte2 [ 4 ]
    };

    interface(base : addr) {
        mmio pte [base, 0, 4]
    };

    fn valid() -> bool { true }

    // matches a translation flags,
    fn matchflags(flgs : flags) -> bool { true }

    // the translation semantics, adding an option type?
    fn translate(va: vaddr) -> paddr
    {
        va
    }

    synth fn unmap(va: vaddr, sz: size)
    synth fn map(va: vaddr, sz: size, flgs: flags, pa : paddr)
    synth fn protect(va: vaddr, sz: size, flgs: flags)
}